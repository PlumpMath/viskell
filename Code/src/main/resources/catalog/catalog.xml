<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="catalog.xsl" ?>
<catalog version="0.4">
    <classes> 
        <class name="Eq">
            <instance name="Int"/>
            <instance name="Ordering"/>
            <instance name="Float"/>
            <instance name="Double"/>
            <instance name="Char"/>
            <instance name="Bool"/>
        </class>
        <class name="Ord">
        	<instance name="Ordering"/>
        	<instance name="Bool"/>
        	<instance name="Char"/>
        	<instance name="Double"/>
        	<instance name="Float"/>
        	<instance name="Int"/>
        </class>   	
        <class name="Num">
            <instance name="Int"/>
            <instance name="Integer"/>
            <instance name="Float"/>
            <instance name="Double"/>
        </class>
        <class name="Fractional">
            <instance name="Float"/>
            <instance name="Double"/>
        </class>
        <class name="Floating">
            <instance name="Float"/>
            <instance name="Double"/>
        </class>
        <class name="Integral">
            <instance name="Int"/>
        </class>
        <class name="Real">
        	<instance name="Int"/>
        	<instance name="Integer"/>
        	<instance name="Float"/>
        	<instance name="Double"/>
        </class>
        <class name="RealFrac">
            <instance name="Float"/>
            <instance name="Double"/>
        </class>
        <class name="Enum">
            <instance name="Ordering"/>
            <instance name="Integer"/>
            <instance name="Int"/>
            <instance name="Char"/>
            <instance name="Bool"/>
            <instance name="Float"/>
            <instance name="Double"/>
        </class>
        <class name="RealFloat">
        	<instance name="Float"/>
        	<instance name="Double"/>
        </class>
        <class name="Show">
        	<instance name="Ordering"/>
        	<instance name="Integer"/>
        	<instance name="Int"/>
        	<instance name="Char"/>
        	<instance name="Bool"/>
        	<instance name="Float"/>
        	<instance name="Double"/>
        </class>
        <class name="Read">
        	<instance name="Ordering"/>
        	<instance name="Integer"/>
        	<instance name="Int"/>
        	<instance name="Char"/>
        	<instance name="Bool"/>
        	<instance name="Float"/>
        	<instance name="Double"/>
        </class>
    </classes>
    
    
    <functions>
        <category name="Basic">
        	<function name="(&amp;&amp;)" signature="Bool -> Bool -> Bool">
				and
            </function>
        	<function name="(||)" signature="Bool -> Bool -> Bool">
        		or
        	</function>
        	<function name="not" signature="Bool -> Bool">
        		not
        	</function>
        	<function name="otherwise" signature="Bool">
        		otherwise is defined as the value True. It helps to make guards more readable.
        	</function>
        </category>
        <category name="Tuples">
        	<function name="fst" signature="(a, b) -> a">
        		Extract the first component of a pair.
        	</function>
        	<function name="snd" signature="(a, b) -> b">
        		Extract the second component of a pair
        	</function>
        	<function name="curry" signature="((a, b) -> c) -> (a, b) -> c">
        		curry converts an uncurried function to a curried function
        	</function>
        	<function name="uncurry" signature="(a -> b -> c) -> (a, b) -> c">
        		uncurry converts a curried function to a function on pairs
        	</function>
        </category>
        <category name="Equality">
        	<function name="(==)" signature="Eq a => a -> a -> Bool"></function>
        	<function name="(/=)" signature="Eq a => a -> a -> Bool"></function>
        	<function name="(&lt;)" signature="Ord a => a -> a -> Bool"></function>
        	<function name="(&lt;=)" signature="Ord a => a -> a -> Bool"></function>
        	<function name="(&gt;)" signature="Ord a => a -> a -> Bool"></function>
        	<function name="(&gt;=)" signature="Ord a => a -> a -> Bool"></function>
        	<function name="max" signature="Ord a => a -> a -> a"></function>
        	<function name="min" signature="Ord a => a -> a -> a"></function>
        </category>
        <category name="Enum functions">
        	<function name="succ" signature="Enum a => a -> a">
        		The successor of a value.
        	</function>
        	<function name="pred" signature="Enum a => a -> a">
        		The predecessor of a value.
        	</function>
        	<function name="toEnum" signature="Enum a => Int -> a">
        		Convert from an Int.
        	</function>
        	<function name="fromEnum" signature="Enum a => a -> Int">
        		Convert to an Int. It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int.
        	</function>
        	<function name="enumFrom" signature="Enum a => a -> [a]">
        		Used in Haskell's translation of [n..].
        	</function>
        	<function name="enumFromThen" signature="Enum a => a -> a -> [a]">
        		used in Haskell's translation of [n, n'..].
        	</function>
        	<function name="enumFromTo" signature="Enum a => a -> a -> [a]">
        		used in Haskell's translation of [n..m].
        	</function>
        	<function name="enumFromThenTo" signature="Enum a => a -> a -> a -> [a]">
        		used in Haskell's translation of [n, n'..m].
        	</function>
        </category>
        <category name="Numeric types">
			<function name="(+)" signature="Num a => a -> a -> a">
				Mathematical addition.
			</function>
			<function name="(*)" signature="Num a => a -> a -> a">
				Mathematical multiplication.
			</function>
			<function name="(-)" signature="Num a => a -> a -> a">
				Mathematical subtraction.
			</function>
        	<function name="negate" signature="Num a => a -> a">
        		Unary negation.
        	</function>
        	<function name="abs" signature="Num a => a -> a">
        		Absolute value.
        	</function>
        	<function name="signum" signature="Num a => a -> a">
        		Sign of a number.
        	</function>
        	<function name="fromInteger" signature="Num a => Integer -> a">
        		Conversion from an Integer. An integer literal represents the application of the
        		function fromInteger to the appropriate value of type Integer, so such literals have
        		type (Num a) => a.
        	</function>
        	<function name="toRational" signature="Real a => a -> Rational">
        		the rational equivalent of its real argument with full precision.
        	</function>
        	<function name="quot" signature="Integral a => a -> a -> a">
        		integer division truncated toward zero.
        	</function>
        	<function name="rem" signature="Integral a => a -> a -> a">
        		integer remainder, satisfying (x 'quot' y)*y + (x 'rem' y) == x.
        	</function>
        	<function name="div" signature="Integral a => a -> a -> a">
        		integer division truncated toward negative infinity.
        	</function>
        	<function name="mod" signature="Integral a => a -> a -> a">
        		integer modulus, satisfying (x 'div' y)*y + (x 'mod y) == x.
        	</function>
        	<function name="quotRem" signature="Integral a => a -> a -> (a, a)">
        		simultaneous quot and rem.
        	</function>
        	<function name="divMod" signature="Integral a => a -> a -> (a, a)">
        		simultaneous div and mod.
        	</function>
        	<function name="toInteger" signature="Integral a => a -> Integer">
        		Conversion to Integer.
        	</function>
        	<function name="(/)" signature="Fractional a => a -> a -> a">
        		fractional division.
        	</function>
        	<function name="recip" signature="Fractional a => a -> a">
        		reciprocal division.
        	</function>
        	<function name="fromRational" signature="Fractional a => Rational -> a">
        		Conversion from a Rational (that is Ratio Integer).
        	</function>
        	<function name="pi" signature="Floating a => a"></function>
        	<function name="exp" signature="Floating a => a -> a"></function>
        	<function name="log" signature="Floating a => a -> a"></function>
        	<function name="sqrt" signature="Floating a => a -> a"></function>
        	<function name="(**)" signature="Floating a => a -> a -> a"></function>
        	<function name="logBase" signature="Floating a => a -> a -> a"></function>
        	<function name="sin" signature="Floating a => a -> a"></function>
        	<function name="cos" signature="Floating a => a -> a"></function>
        	<function name="tan" signature="Floating a => a -> a"></function>
        	<function name="asin" signature="Floating a => a -> a"></function>
        	<function name="acos" signature="Floating a => a -> a"></function>
        	<function name="atan" signature="Floating a => a -> a"></function>
        	<function name="sinh" signature="Floating a => a -> a"></function>
        	<function name="cosh" signature="Floating a => a -> a"></function>
        	<function name="tanh" signature="Floating a => a -> a"></function>
        	<function name="asinh" signature="Floating a => a -> a"></function>
        	<function name="acosh" signature="Floating a => a -> a"></function>
        	<function name="atanh" signature="Floating a => a -> a"></function>
        	<function name="properFraction" signature="(RealFrac a, Integral b) => a -> (b, a)">
        		The function properFraction takes a real fractional number x and returns a pair (n,f) such that x = n+f, and:
        		- n is an integral number with the same sign as x; and
        		- f is a fraction with the same type and sign as x; and with absolute value less than 1.
        	</function>
        	<function name="truncate" signature="(RealFrac a, Integral b) => a -> b">
        		truncate x returns the integer nearest x between zero and x
        	</function>
        	<function name="round" signature="(RealFrac a, Integral b) => a -> b">
        		round x returns the nearest integer to x; the even integer if x is equidistant between two integers.
        	</function>
        	<function name="ceiling" signature="(RealFrac a, Integral b) => a -> b">
        		ceiling x returns the least integer not less than x.
        	</function>
        	<function name="floor" signature="(RealFrac a, Integral b) => a -> b">
        		floor x returns the greatest integer not greater than x.
        	</function>
        	<function name="isNaN" signature="RealFloat a => a -> Bool">
        		True if the argument is an IEEE "not-a-number" (NaN) value.
        	</function>
        	<function name="isInfinite" signature="RealFloat a => a -> Bool">
        		True if the argument is an IEEE infinity or negative infinity
        	</function>
        	<function name="isDenormalized" signature="RealFloat a => a -> Bool">
        		True if the argument is too small to be represented in normalized format.
        	</function>
        	<function name="isNegativeZero" signature="RealFloat a => a -> Bool">
        		True if the argument is an IEEE negative zero.
        	</function>
        	<function name="isIEEE" signature="RealFloat a => a -> Bool">
        		True if the argument is an IEEE floating point number.
        	</function>
        	<function name="atan2" signature="RealFloat a => a -> a -> a">
        		a version of arctangent taking two real floating-point arguments. For real floating x and 
        		y, atan2 y x computes the angle (from the positive x-axis) of the vector from the 
        		origin to the point (x,y). atan2 y x returns a value in the range [-pi, pi]. It follows 
        		the Common Lisp semantics for the origin when signed zeroes are supported. atan2 y 
        		1, with y in a type that is RealFloat, should return the same value as atan y. A 
        		default definition of atan2 is provided, but implementors can provide a more accurate 
        		implementation.
        	</function>
        	<function name="even" signature="Integral a => a -> Bool"></function>
        	<function name="odd" signature="Integral a => a -> Bool"></function>
        	<function name="gcd" signature="Integral a => a -> a -> a">
        		gcd x y is the non-negative factor of both x and y of which every common factor of x and 
        		y is also a factor; for example gcd 4 2 = 2, gcd (-4) 6 = 2, gcd 0 4 = 4. gcd 0 0 
        		= 0. (That is, the common divisor that is "greatest" in the divisibility preordering.)

				Note: Since for signed fixed-width integer types, abs minBound &lt; 0, the result may be
				negative if one of the arguments is minBound (and necessarily is if the other is 0 or 
				minBound) for such types.
        	</function>
        	<function name="lcm" signature="Integral a => a -> a -> a">
        		lcm x y is the smallest positive integer that both x and y divide.
        	</function>
        	<function name="(^)" signature="(Num a, Integral b) => a -> b -> a">
        		raise a number to an non-negative integral power.
        	</function>
        	<function name="(^^)" signature="(Integral b, Fractional a) => a -> b -> a">
        		raise a number to an integral power
        	</function>
        	<function name="fromIntegral" signature="(Num b, Integral a) => a -> b">
        		general coercion from integral types.
        	</function>
        	<function name="realToFrac" signature="(Real a, Fractional b) => a -> b">
        		general coercion to fractional types
        	</function>
        </category>
        <category name="Maps, folds and lists">
            <function name="head" signature="[a] -> a">
                Extract the first element of a list, which must be non-empty.
            </function>
        </category>
        <category name="Assorted">
            <function name="id" signature="a -> a" >
                Identity function.
            </function>
            <function name="const" signature="a -> b -> a">
                Constant function.
            </function>
            <function name="undefined" signature="a">
                Undefined function.
            </function>
        </category>
    </functions>
</catalog>
