\chapter{Design}

\section{Languages and libraries}

% Java. Why?
% JavaFX. Why?
% TactileFX. Why?

\section{High-level architecture}

% Frontend/backend split
% Communication between frontend and backend (when we've got that settled)

\section{Backend architecture}

A result of our design choices is that our Java program needs to have a basic understanding of the Haskell programming
language. For this purpose we implemented two tree structures - one for expressions, one for types - supported by an
interface for GHCi, a type signature parser and a catalog.

\subsection{Communication with GHCi}
\index{GHCi}

The base of the back-end is an interface for communication with GHCi. This interface allows us to run Haskell code
generated by the users of our application. As implementing a complete type checker for Haskell is a major challenge this
interface can also be used to check a program for faults.

\subsection{Type system and type checker}

The error messages from GHCi are hard to parse and do not always provide detailed information about where the error
occured. Therefore we implemented our own type checker. This type checker is designed to catch most of the type errors
which are in the design scope of the project and not raise false negatives. Pushing Haskell code to GHCi is still needed
to be sure that the code compiles (and will always be needed to catch runtime errors).

Internally Haskell types are represented as instances of a class. These instances can be tied together to form a
tree-like structure. This approach is chosen because it is easy to work with class instances and nested types form
a tree-like structure. \index{type tree}

The type checker is implemented using Hindley-Milner type inference. We use this algorithm to (try to) unify two
types. If the types cannot be unified, there exists a type error. The algorithm is described in detail by
\cite{borisov}. \index{Hindley-Milner} \index{type inference}

\subsection{Expressions}

Haskell expressions are represented in a tree. By design each function can have only one argument. Functions with more
arguments are represented as a function with a single argument that produces another function with the other arguments.
Each expression holds its type including the types from the lower part of the expression tree. The root of the
expression tree therefore always knows the type of the whole tree.

Function application can be done using a special kind of expression. This is done so function application does not
directly modify other expressions in the tree. This allows for easy changes in the frontend. Types of expressions can
be updated on-the-fly taking into account the types that are applied to the arguments of functions.

The expressions that are available in the application are stored in a catalog. This catalog contains functions that are
by default available in Haskell and are known to work with the application.
