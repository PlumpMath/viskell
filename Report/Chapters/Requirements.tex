\chapter{Requirements Analysis}

The first step in creating an application or program was defining the requirements. In order to do this, we planned meetings with our client.
While it initially appeared as he had not may demands for the project, he had mixed feelings for our early UI concepts (a circular menu). After talking this through, we soon found out that he did like us to somewhat stick to his initial ideas at the very least in terms of user interface. The main goal of the project was not to create a program, which is 100\% finished and could be used right away, but to explore the possibilities of the client's ideas (a proof of concept).

To start however, we needed something more than just an idea. We needed a base from which we could work. This resulted in a set of requirements, which we defined based on the ideas of our client and were adjusted throughout the project based on received feedback.

\section{Target audience}

How to divide the requirements in necessary and desirable requirements depends on the kind of target audience for which the application is designed. \index{audience} \index{target audience}

In this project the focus lied mainly on users who already know how to program in Haskell. This included people who are just starting with Haskell.
The goal of the program was to aid these users in creating an overview of their program and informing them about (possible) mistakes without the user having to write a complete program and then compile it.

Furthermore, it was assumed that the users would generally be advanced computer users and therefore did not require an in-depth explanation on how to operate a program. The users were also expected to have a basic understanding of touch gestures, most likely obtained through the use of a smart phone or tablet.

\section{Hardware}

The program was to be designed for use on a large multi-touch screen with a screen resolution of 1920x1080 pixels, but also needed to work with a smaller (for example laptop) screen and a mouse. The program should be efficient enough to run on average modern-day hardware. The client provided a desktop computer and multi-touch screen for reference.

\section{Requirements}

For this project, the requirements could be divided in three categories, namely: visual requirements, functional requirements and multi-touch requirements. In the following subsections each of the categories will be discussed. In some cases a requirement fits in multiple groups; in these cases the best fitting group has been chosen to contain this requirement.

\begin{enumerate}
\item \subsection*{Visual requirements} \index{visual requirements}

\begin{enumerate}
	\item The structure of the visual program must logically represent the structure of a regular Haskell program.
		\begin{enumerate}
			\item Haskell functions are represented by a separate element.
			\item The program has to be able to show a compact notation for a program using stacked and nested blocks.
			\item Blocks must be movable to prevent them from overlap.
		\end{enumerate}
	\item The program must allow functions/blocks to be interconnected.
		\begin{enumerate}
			\item Function arguments must be connected individually.
			\item A block has a single output which can be the final result of the function or the result of a partial application.
		\end{enumerate}
	\item The user interface design must be minimalistic.
	\item The user interface must be resizable.
	\item Actions performed by the user must give feedback.
	\item Errors and warnings (for example type errors) must be easily recognizable.
	\item In case blocks and lines overlap, lines must be drawn behind the blocks.
	\item Users must be able to select functions using a touch screen only.
\end{enumerate}

\item \subsection*{Functional requirements} \index{functional requirements}

\begin{enumerate}
	\item The program has to support incomplete programs.
	\begin{enumerate}
		\item It must be possible to have blocks or groups of blocks that are not interconnected.
		\item The program must give feedback (for example type errors) about incomplete programs.
	\end{enumerate}
	\item It must be possible to define custom Haskell functions. This includes a free choice in number of arguments, type and name of the function.
	\item The program must generate executable Haskell code from the visual representation. This implies that objects in the visual representation have a precise meaning.
	\item The program must perform real-time type checking of the connected functions.
	\item The program must be able to show the real-time output at any point in the program. The user may be required to perform a small number of actions to achieve this.
	\item The program must be expandable by different developers.
	\begin{enumerate}
		\item The source code must be documented properly.
		\item The design choices must be documented properly.
	\end{enumerate}
\end{enumerate}

\item \subsection*{Multi-touch requirements} \index{multi-touch requirements}

\begin{enumerate}
	\item Users with large fingers should be able to use the program. This may be achieved with either large visual elements or touch areas larger than the visual element.
	\item Actions may use gestures that are simple and have a short learning curve.
	\item It should be possible to use the program with more than one person at the same time on the same touch screen.
	\item It should be possible to use the program with only one hand.
	\item The program should only require a keyboard as input method when absolutely necessary.
\end{enumerate}

\end{enumerate}
