\chapter{Test Plan}

To test the finished product, we used (automatic) unit tests as well as (manual) acceptance tests.
The unit tests mainly cover the back end of the application because it is difficult to unit test the front end, mainly because of the user interface.
The acceptance tests are focused on the front end.

\section{Acceptance tests}



\section{Unit tests}

A large part of the back end is covered by unit tests.
Almost all tests focus on the Haskell representation to make sure that the Haskell code generated by the program is as expected.
The type parser is also tested extensively to make sure types are consistent and no invalid type errors are raised.

The following parts are covered by the unit tests:

\begin{enumerate}
	\item GHCJ
	\begin{enumerate}
		\item Evaluating expressions
		\item Retrieving expressions
	\end{enumerate}
	\item Haskell catalog
	\begin{enumerate}
		\item Parsing of categories
		\item Parsing of default functions
		\item Parsing of type classes
	\end{enumerate}
	\item Expressions
	\begin{enumerate}
		\item Haskell code representation
		\item Types of expressions
		\item Inferred types of expressions
	\end{enumerate}
	\item Types and type classes
	\begin{enumerate}
		\item Haskell signature representation
		\item Type propagation
		\item Type inference: unification
		\item Type inference: pruning
		\item Deep copying
		\item Equality
	\end{enumerate}
	\item Type parser
	\begin{enumerate}
		\item Parsing of constant types, variable types with and without type classes, function types, list types, tuple types
		\item Parsing of complex, combined types
	\end{enumerate}
\end{enumerate}

The tests are not described in detail here, the exact test cases are included in the source code.
